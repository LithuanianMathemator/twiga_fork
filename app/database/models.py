from typing import Any, List, Optional
from datetime import datetime, timezone
from sqlmodel import Field, SQLModel
from pydantic import field_validator
from sqlalchemy import Column, DateTime, String, ARRAY, JSON
from pgvector.sqlalchemy import Vector
import sqlalchemy as sa

# TODO: update the foreign keys to use the new table names


class User(SQLModel, table=True):
    __tablename__ = "users"

    # The id is optional because it will be generated by the database
    id: Optional[int] = Field(default=None, primary_key=True)
    name: Optional[str] = Field(max_length=50)
    wa_id: str = Field(max_length=20, unique=True, index=True)
    state: str = Field(max_length=20)
    role: str = Field(default="teacher", max_length=20)
    class_info: Optional[dict] = Field(default=None, sa_type=JSON)
    last_message_at: Optional[datetime] = Field(
        sa_column=DateTime(timezone=True)
    )  # user.last_message_at = datetime.now(timezone.utc) (this is how to set it when updating later)
    created_at: datetime = Field(
        sa_column=DateTime(timezone=True),
        default_factory=lambda: datetime.now(timezone.utc),
    )

    updated_at: datetime = Field(
        sa_column=DateTime(timezone=True),
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column_kwargs={"onupdate": sa.func.now()},
    )


class Class(SQLModel, table=True):
    __tablename__ = "classes"
    id: Optional[int] = Field(default=None, primary_key=True)
    subject: str = Field(max_length=30)
    grade_level: int = Field()


class TeacherClass(SQLModel, table=True):
    __tablename__ = "teachers_classes"
    id: Optional[int] = Field(default=None, primary_key=True)
    teacher_id: int = Field(foreign_key="user.id")
    class_id: int = Field(foreign_key="class.id")


class Resource(SQLModel, table=True):
    __tablename__ = "resources"
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(max_length=100)
    type: Optional[str] = Field(max_length=30)
    authors: List[str] = Field(sa_column=Column(ARRAY(String(50))))
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class ClassResource(SQLModel, table=True):
    __tablename__ = "classes_resources"
    id: Optional[int] = Field(default=None, primary_key=True)
    class_id: int = Field(foreign_key="class.id")
    resource_id: int = Field(foreign_key="resource.id")


class Section(SQLModel, table=True):
    __tablename__ = "sections"
    id: Optional[int] = Field(default=None, primary_key=True)
    resource_id: int = Field(foreign_key="resource.id")
    parent_section_id: Optional[int] = Field(default=None, foreign_key="section.id")
    section_index: Optional[str] = Field(max_length=20)
    section_title: Optional[str] = Field(max_length=100)
    section_type: Optional[str] = Field(max_length=15)
    section_order: int
    page_range: Optional[str] = Field(default=None)
    summary: Optional[str] = Field(default=None)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class Chunk(SQLModel, table=True):
    __tablename__ = "chunks"
    id: Optional[int] = Field(default=None, primary_key=True)
    resource_id: int = Field(foreign_key="resource.id")
    section_id: int = Field(foreign_key="section.id")
    content: Optional[str] = Field(default=None)
    page: Optional[int] = Field(default=None)
    content_type: Optional[str] = Field(max_length=30)
    embedding: Optional[Any] = Field(default=None, sa_column=Column(Vector(1536)))
    top_level_section_index: Optional[str] = Field(max_length=10)
    top_level_section_title: Optional[str] = Field(max_length=100)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class Message(SQLModel, table=True):
    __tablename__ = "messages"
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id")
    role: str = Field(max_length=20)
    content: Optional[str] = Field(default=None)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    @field_validator("role")
    @classmethod
    def validate_role(cls, v: str) -> str:
        if v not in ["user", "assistant", "system", "context", "tool"]:
            raise ValueError("Invalid role")
        return v
